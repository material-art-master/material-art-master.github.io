[{"content":"Problem: https://codeforces.com/contest/1771/problem/F\nSolution: The problem asked us to find the smallest number in a given sequence, which occurs an odd number of times in online. To solve this problem, we can use a persistent segment tree with binary search or walk on segment tree technique to solve the problem. But it has a probability of xor of some number equal to 0 (Like 1 xor 2 xor 3). To prevent it, we can just simply map each number with a random 64-bit number.\nCode: Using binary search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 2e5+6; const int MOD = 1e9+7; struct Vertex { Vertex *l, *r; int sum; Vertex(int val) : l(nullptr), r(nullptr), sum(val) {} Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) { if (l) sum ^= l-\u0026gt;sum; if (r) sum ^= r-\u0026gt;sum; } }; Vertex* build(vector\u0026lt;int\u0026gt; \u0026amp;a, int tl, int tr) { if (tl == tr) return new Vertex(a[tl]); int tm = (tl + tr) / 2; return new Vertex(build(a, tl, tm), build(a, tm+1, tr)); } int get_sum(Vertex* v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return 0; if (l == tl \u0026amp;\u0026amp; tr == r) return v-\u0026gt;sum; int tm = (tl + tr) / 2; return get_sum(v-\u0026gt;l, tl, tm, l, min(r, tm)) + get_sum(v-\u0026gt;r, tm+1, tr, max(l, tm+1), r); } Vertex* update(Vertex* v, int tl, int tr, int pos, int new_val) { if (tl == tr) return new Vertex(new_val^v-\u0026gt;sum); int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) return new Vertex(update(v-\u0026gt;l, tl, tm, pos, new_val), v-\u0026gt;r); else return new Vertex(v-\u0026gt;l, update(v-\u0026gt;r, tm+1, tr, pos, new_val)); } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//64-bit number generator int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n+1), b(n+1); FOR(i,1,n) { cin \u0026gt;\u0026gt; b[i]; a[i] = b[i]; } sort(b.begin()+1, b.end());//b is the original a FOR(i,1,n) a[i] = lower_bound(b.begin()+1, b.end(), a[i]) - b.begin(); vector\u0026lt;int\u0026gt; tmp(n+1, 0); vector\u0026lt;Vertex*\u0026gt; roots(n+1); roots[0] = build(tmp, 1, n); FOR(i,1,n) tmp[i] = rng(); FOR(i,1,n) { roots[i] = update(roots[i-1],1,n,a[i],tmp[a[i]]); } int res = 0; int Q, ql, qr; cin \u0026gt;\u0026gt; Q; while (Q--) { cin \u0026gt;\u0026gt; ql \u0026gt;\u0026gt; qr; ql^= res; qr^= res; int l = 1, r = n, found = false; while (l\u0026lt;=r) { int mid = (l+r)/2; if (get_sum(roots[qr], 1, n, 1, mid)^get_sum(roots[ql-1], 1, n, 1, mid)) { found = true; r = mid-1; res = mid; } else l = mid+1; } res = b[res]; if (!found) res = 0; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } Using walk on segment tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 2e5+6; const int MOD = 1e9+7; struct Vertex { Vertex *l, *r; int sum; Vertex(int val) : l(nullptr), r(nullptr), sum(val) {} Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) { if (l) sum ^= l-\u0026gt;sum; if (r) sum ^= r-\u0026gt;sum; } }; Vertex* build(vector\u0026lt;int\u0026gt; \u0026amp;a, int tl, int tr) { if (tl == tr) return new Vertex(a[tl]); int tm = (tl + tr) / 2; return new Vertex(build(a, tl, tm), build(a, tm+1, tr)); } int get_sum(Vertex* v, int tl, int tr, int l, int r) { if (l \u0026gt; r) return 0; if (l == tl \u0026amp;\u0026amp; tr == r) return v-\u0026gt;sum; int tm = (tl + tr) / 2; return get_sum(v-\u0026gt;l, tl, tm, l, min(r, tm)) + get_sum(v-\u0026gt;r, tm+1, tr, max(l, tm+1), r); } int query(Vertex *vl, Vertex *vr, int tl, int tr) { //find the first position x such that sum_xor[1..x] != 0 if (tl==tr) { if (vr-\u0026gt;sum ^ vl-\u0026gt;sum) return tl; else return 0; } int tm = (tl + tr)/2; int left_xor_sum = vr-\u0026gt;l-\u0026gt;sum ^ vl-\u0026gt;l-\u0026gt;sum; if (left_xor_sum) { return query(vl-\u0026gt;l, vr-\u0026gt;l, tl, tm); } else return query(vl-\u0026gt;r, vr-\u0026gt;r, tm+1, tr); } Vertex* update(Vertex* v, int tl, int tr, int pos, int new_val) { if (tl == tr) return new Vertex(new_val^v-\u0026gt;sum); int tm = (tl + tr) / 2; if (pos \u0026lt;= tm) return new Vertex(update(v-\u0026gt;l, tl, tm, pos, new_val), v-\u0026gt;r); else return new Vertex(v-\u0026gt;l, update(v-\u0026gt;r, tm+1, tr, pos, new_val)); } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());//64-bit number generator int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n+1), b(n+1); FOR(i,1,n) { cin \u0026gt;\u0026gt; b[i]; a[i] = b[i]; } sort(b.begin()+1, b.end());//b is the original a FOR(i,1,n) a[i] = lower_bound(b.begin()+1, b.end(), a[i]) - b.begin(); vector\u0026lt;int\u0026gt; tmp(n+1, 0); vector\u0026lt;Vertex*\u0026gt; roots(n+1); roots[0] = build(tmp, 1, n); FOR(i,1,n) tmp[i] = rng(); FOR(i,1,n) { roots[i] = update(roots[i-1],1,n,a[i],tmp[a[i]]); } int res = 0; int Q, ql, qr; cin \u0026gt;\u0026gt; Q; while (Q--) { cin \u0026gt;\u0026gt; ql \u0026gt;\u0026gt; qr; ql^= res; qr^= res; res = query(roots[ql-1], roots[qr],1,n); res = b[res]; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } ","date":"2022-12-17T00:00:00Z","image":"https://material-art-master.github.io/p/codeforces-1771f.-hossam-and-range-minimum-query/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/codeforces-1771f.-hossam-and-range-minimum-query/","title":"Codeforces 1771F. Hossam and Range Minimum Query"},{"content":"Problem: https://atcoder.jp/contests/arc074/tasks/arc074_c\nSolution: Let\u0026rsquo;s $dp[r][g][b]$ is the number of ways to paint the sequence with $r, g, b$ is the last position corresponding to each color. We can see that the current position we are considering is $max(r,g,b)$ Let\u0026rsquo;s $i = max(r,g,b)$ then we can also check every constraint with right-endpoint at the position $i$. The rest of the problem is very easy to do.\nCode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //prob: https://atcoder.jp/contests/arc074/tasks/arc074_c #include \u0026lt;bits/stdc++.h\u0026gt; #define fi first #define se second #define ll long long #define ld long double #define ii pair\u0026lt;int, int\u0026gt; #define FOR(i,a,b) for (int i=a; i\u0026lt;=b; ++i) #define FORD(i,b,a) for (int i=b; i\u0026gt;=a; --i) using namespace std; const int MAX = 3e2+6; const int MOD = 1e9+7; vector\u0026lt;ii\u0026gt; constraints[MAX]; int dp[MAX][MAX][MAX]; bool Check(int r, int g, int b, int cur_pos) { for(auto \u0026amp;tmp: constraints[cur_pos]) { int l = tmp.fi, x = tmp.se, cnt = 0; if (r \u0026gt;= l) cnt++; if (g \u0026gt;= l) cnt++; if (b \u0026gt;= l) cnt++; if (cnt != x) return false; } return true; } int main(int argc, char const *argv[]) { cin.tie(0)-\u0026gt;sync_with_stdio(0); if (fopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;)){ freopen(\u0026#34;input.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); } int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; FOR(i,1,m) { int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; constraints[r].push_back({l,x}); } if (Check(1,0,0,1)) dp[1][0][0] = dp[0][1][0] = dp[0][0][1] = 1; int res = 0; FOR(r,0,n) { FOR(g,0,n) { FOR(b,0,n) { int i = max({r,g,b}); if (Check(i+1,g,b, i+1)) { dp[i+1][g][b]+= dp[r][g][b]; dp[i+1][g][b]%= MOD; } if (Check(r,i+1,b, i+1)) { dp[r][i+1][b]+= dp[r][g][b]; dp[r][i+1][b]%= MOD; } if (Check(r,g,i+1, i+1)) { dp[r][g][i+1]+= dp[r][g][b]; dp[r][g][i+1]%= MOD; } if (i==n) { res+= dp[r][g][b]; res%= MOD; } } } } cout \u0026lt;\u0026lt; res; return 0; } ","date":"2022-12-17T00:00:00Z","image":"https://material-art-master.github.io/p/e-rgb-sequence/CP_hue11b2ba56b08fdca03eb474b3b557450_17864_120x120_fill_q75_box_smart1.jpg","permalink":"https://material-art-master.github.io/p/e-rgb-sequence/","title":"E - RGB Sequence"}]